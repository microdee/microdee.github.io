<!-- {
    "title": "Nuke.Unreal",
    "desc": "Automate the tasks involved in creating Marketplace complaint plugins and other useful scripts"
} -->

# Nuke.Unreal
[(10.04.2021)](/c/log/nuke-unreal)

<tocmd>
- [Nuke.Unreal](#nuke-unreal)
    - [Get it here](#get-it-here)
  - [TL;DR features](#tl-dr-features)
  - [Prelude/Reasoning](#prelude-reasoning)
  - [Setup](#setup)
    - [Scaffolding](#scaffolding)
    - [Working with UE4 Plugins](#working-with-ue4-plugins)
  - [Generate boilerplate code](#generate-boilerplate-code)
    - [Templating](#templating)
  - [Fluent Unreal Tools API](#fluent-unreal-tools-api)
</tocmd>

![_parallax(side)](../nu_logo.svg)

This article is about using C# and [Nuke](https://nuke.build) to automate tasks and build steps around your Unreal project. It will generally describe the workflow and how to set it up yourself. This is still deep in development so this article should be a teaser-trailer really.

### [Get it here](https://github.com/microdee/Nuke.Unreal)

## TL;DR features

* Common UE4 build tasks (generate project files, build editor, cook, package, etc)
* Prepare plugins for release in Marketplace
* Bind Unreal tools to Nuke with fluent C# API *\[very WIP\]*
* Generate boilerplate code and scaffolding from Scriban templates so no editor or heavy IDE needs to be opened
  * New Unreal classes
  * New Plugin
  * New Module
* Find UE4 installations automatically

## Prelude/Reasoning

Recently I had some time and incentive to finally updgrade the way I package my projects and plugins and I figured I'll share you how that went. Until recently anytime I needed to automate a certain task I've just wrote a simple script in Powershell and called it a day, and carry on working on more pressing issues of the given project. Of course I've made some modules to collect common functions but that was the only thing somewhat encompassing the individual scripts. One out of many problems with it is that dependency between scripts could be only expressed by directly calling them in each other. This alone of course is the root of many evil and results in rigid code which feels clunky to work with. Extending such a codebase even when it's "only" about automation, feels like walking through a minefield.

Of course build automation packages and CI/CD systems are built specifically to solve problems like this, and now I can ruin my vacation trying to force one of them to work with Unreal Engine. Unreal itself has its own automation workflow buuut it suffers from recurring problems around their ecosystem: documentation is a single A4 page article, it is a pain to work with, don't embrace external tools and libraries which would improve productivity tenfold, and it's only available when you're working with engine source for your project.

To cut this short I went with **Nuke** out of some alternatives I considered (CAKE, PSake, FAKE, Gradle, Meson). It also felt natural to use a tool which you program with C# since Unreal itself uses C# to configure its targets and modules (albeit a pretty old language version).

## Setup

To initialize it with your project execute this:

```Powershell
iex ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/microdee/Nuke.Unreal.WorkflowTemplate/main/Setup.ps1'))
```

It will install the necessary boilerplate, [see Scaffolding](#scaffolding).

[You can read the Nuke.Unreal setup instructions here](https://github.com/microdee/Nuke.Unreal#usage)

You can go to Nuke's own documentation to see [detailed setup instructions](https://nuke.build/docs/getting-started/setup.html) for any of your project, but TL;DR: it creates a dotnet console application for you where you can define your targets as properties in a `Build` class, and program it like any other C# application out there. Additionally it places some extra files and scripts in your project root, to make everyone's life so much easier.

Nuke's documentation suggests couple of strategies to share build tasks, one of them being submodules. I will use them for now, because they require the least immediate boilerplate while developing and testing them and the least amount of chore to publish changes.

### Scaffolding

The recommended file/folder structure only considering the user modifyable parts of the Nuke.Unreal workflow:

```
Project Root
    Nuke.Targets
        Build.cs
        _build.csproj
        etc
    Nuke.Unreal (submodule)
    .nuke
    build.cmd
    build.sh
    build.ps1
    Build.sln
```

Notice I also use a `Build.sln` soltuion generated by the Nuke global tool, so I have an easier time with dotnet and managing build related projects. It is not required but I recommend it. This also means now that in your Unreal specific `.gitignore` you should not do `*.sln`.

### Working with UE4 Plugins

Nuke.Unreal always have to work with an Unreal project. This seems trivial but it means you need to have a test-project for developing and publishing plugins with it. I actually have two repositories for this purpose: one for the test-project and one for purely the plugin as a submodule. This allows for easy inclusion of it in other C++ projects as well.

Note this separation means that the build scripts are not shipped with the plugin submodule. For self contained plugins where no pre-processing is necessary for UE4 to build it, it's fine. This actually allows the plugin to be used in code projects without Nuke. IMO the C# build scripts of UBT should be powerful enough for any elaborate scenarios. If absolutely necessary (read: very unlikely), one could make a `Nuke.MyPlugin` C# class library, and use that as a dependency in the importing UE projects' `Nuke.Targets` build project. Not the best practice though because it makes your plugin depend on at least `Nuke` if not `Nuke.Unreal`

## Generate boilerplate code

Because the Nuke global tool can be executed in any subfolder in the project, it allows the developer to exploit some targets to become part of the programming workflow. In short it means with Nuke unreal one can do this:

```
> nuke NewActor --name MyPreciousActor
```

which results in creating the proper header/source files for the `AMyPreciousActor` with the correct code boilerplate, the public/private folder scaffolding, and the correct MODULE_API macros. There are several other UE4 units which can be generated like this

```
> nuke NewActor --name MyPreciousActor
> nuke NewInterface --name MyPreciousInterface
> nuke NewObject --name MyPreciousObject
> nuke NewStruct --name MyPreciousStruct
> nuke NewModule --name MyPreciousModule
> nuke NewPlugin --name MyPreciousPlugin
```

### Templating

These are actually generated via [Scriban](https://github.com/scriban/scriban) templates, which is a very powerful and easy to work with templating/scripting DSL. `Nuke.Unreal` allows you to override these templates from your project targets, in case you have a project specific boilerplate code. See for example the Interface header template:

```CPP
// {{ copyright }}

#pragma once

#include "CoreMinimal.h"

#include "{{ name }}.generated.h"

UINTERFACE()
class {{ module.name | string.upcase }}_API U{{ name }} : public UInterface
{
    GENERATED_BODY()
};

class {{ module.name | string.upcase }}_API I{{ name }}
{
    GENERATED_BODY()
public:
```

Scriban templating is also used for file and foldernames, so basically templates are not only single files, but an entire file/folder structure. See for example the [Module template](https://github.com/microdee/Nuke.Unreal/tree/develop/src/Nuke.Unreal/templates/Module/%7B%7B%20name%20%7D%7D). As you can also see `*.sbn*` files are the ones which content will be parsed with Scriban, and the `sbn` part will be removed from their extension upon rendering.

<mdcomment />